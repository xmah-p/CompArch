- [课程概述](#课程概述)
- [计算机基本结构](#计算机基本结构)
  - [电子计算机的兴起](#电子计算机的兴起)
  - [模型机](#模型机)
  - [现代计算机](#现代计算机)
- [指令集](#指令集)
  - [x86 体系结构](#x86-体系结构)
    - [16 位时代：x86-16（IA-16）](#16-位时代x86-16ia-16)
    - [32 位时代：IA-32](#32-位时代ia-32)
    - [64 位时代：x86-64](#64-位时代x86-64)
  - [x86 指令简介](#x86-指令简介)
  - [MIPS 体系结构](#mips-体系结构)
- [算术逻辑单元](#算术逻辑单元)
- [乘法器与除法器](#乘法器与除法器)
  - [乘法器](#乘法器)
  - [除法器](#除法器)
- [单周期处理器](#单周期处理器)
  - [数据通路](#数据通路)
  - [控制信号的集成](#控制信号的集成)

# 课程概述

# 计算机基本结构

## 电子计算机的兴起

**现代电子计算机之父**：冯·诺依曼

ENIAC（Electronic Numerical Integrator and Computer，电子数字积分器和计算机）：

- 首台**通用**电子计算机
- 1946年2月14日
- 1943年开始设计
- 宾夕法尼亚大学
- 约翰·莫克利（首席顾问）、约翰·埃克特（首席工程师）、约翰·冯·诺依曼

ABC（Atanasoff-Berry Computer，阿塔纳索夫-贝里计算机）：

- 比 ENIAC 早，1939年完成
- 首台计算机

冯诺依曼提出**存储程序**概念，在《关于EDVAC的报告草案》提出了冯诺依曼结构。

EDVAC（Electronic Discrete Variable Automatic Computer，电子离散变量自动计算机）：

- 1949年8月交付
- 1951年开始运行
- 冯诺依曼结构
- 存储程序
- 指令和数据采用二进制，简化了逻辑线路
- 五个基本部分：
  - 运算器
  - 控制器
  - 存储器
  - 输入设备
  - 输出设备
- 但第一台冯诺依曼结构计算机是 EDSAC（1949年正式运行）

UNIVAC（UNIVersal Automatic Computer，通用自动计算机）：1951 年交付，1952 年统计选票一战成名，开启了商用计算机时代。

其他经典计算机：

- 1964 年大型计算机 IBM S/360
- 1964 年超级计算机 CDC 6600
- 1965 年小型计算机 PDP-8
- 1975 年微型计算机 Altair 8800
- 1977 年微型计算机 Apple II
- 1981 年微型计算机 IBM PC 5150

## 模型机

存储器（主存）：

- 控制总线连接控制逻辑和地址译码器
- 地址总线连接 Memory Address Register（MAR）
- 数据总线连接 Memory Data Register（MDR）

控制器：

- 指令寄存器（IR）：存当前指令
- 程序计数器（PC）：存下一条指令的地址
- MAR
- MDR
- 指令译码部件
- 控制电路

运算器：

- ALU：算术运算和逻辑运算
- 通用寄存器
- 状态寄存器

CPU：控制器和运算器

总线：

- 内部总线：CPU 内部
- 控制总线：控制器的控制电路和存储器控制逻辑
- 地址总线：存储器 MAR 和控制器 MAR
- 数据总线：存储器 MDR 和控制器 MDR

执行指令的四个步骤：取指、译码、执行、回写

输入输出：就像另一个存储器

## 现代计算机

现代计算机结构：

- CPU
- 北桥：PCIe 控制器、主存控制器、集显
- 南桥：I/O 控制器（硬盘、USB、网卡、PCI 卡、...）

后来，主存控制器、PCIe 控制器、集显（核显）都集成在 CPU 里了。主板只剩下一个 PCH 管 I/O。

再后来发展出了 SOC（System on Chip，片上系统）。

摩尔定律（常见描述）：价格不变，每 18 个月，集成电路上可容纳的晶体管数目翻一番。


# 指令集

简单的指令集示例：

- 运算类：`ADD R, M`
- 传送类：`LOAD R, M`、`STORE M, R`
- 转移类：`JMP L`
- 格式：4 位操作码 + 4 位寄存器号 + 8 位地址

## x86 体系结构

### 16 位时代：x86-16（IA-16）

Intel 8086：

- 1978 年发布
- 16 位通用寄存器，也支持 8 位数据
- 16 根数据线
- 20 根地址线，寻址空间 1MB
- 段 + 偏移量寻址
- 代表计算机 IBM 5150（用的是简化版的 8088）

8086 的寄存器模型：

- 通用寄存器
  - 4 个数据寄存器：AX、BX、CX、DX
    - 每个可分为两个 8 位寄存器使用：AL/AH、BL/BH、CL/CH、DL/DH
  - 指针和变址寄存器：SP、BP、SI、DI
- 指令指针寄存器：IP
- 标志寄存器：FLAGS
  - 标志位有：
    - 状态标志位：CF（进位）、ZF（零）、SF（符号）、OF（溢出）、PF（奇偶）、AF（辅助进位）
    - 控制标志位：DF（方向）、IF（中断）、TF（跟踪）
- 段寄存器：CS、DS、SS、ES
  - CS：代码段寄存器，指向当前执行的代码段
  - DS：数据段寄存器，指向当前数据段
  - SS：堆栈段寄存器，指向当前堆栈段
  - ES：附加数据段寄存器

8086 的寻址方式：

- 指令指针寄存器（IP）保存**下一条指令的地址**（即程序计数器）
- 程序员不能直接操作 IP
- 物理地址 = 段寄存器 * 16 + IP
- 1MB 的存储空间分为许多 64KB 的逻辑段，它们可以重叠
- 指令的操作数默认存放在数据段（DS）中，指令地址默认存放在代码段（CS）中

Intel 80286：

- 24 位地址总线，寻址空间 16MB
- 保护模式，但有缺陷（每个段只有 64KB）
- 实模式（兼容 8086）
- 所有 x86 处理器在加电启动时都首先进入实模式，系统初始化完成后再进入保护模式

### 32 位时代：IA-32

Intel 80386：

- 8086 系列的首款 32 位处理器
- 32 位通用寄存器
- 32 位地址总线，寻址空间 4GB
- 改进的保护模式：段可达 4GB
  - 保护模式是主要工作模式，支持多任务、特权级、特权指令、访问权限、4GB 物理地址空间、虚拟内存
- 虚拟 8086 模式，可以模拟多个 8086 处理器
  - 寻址空间 1MB，段 + 偏移寻址（与实模式相同）
  - 对中断和异常的处理不同于实模式
  - 用于兼容 8086 系统

IA-32 对寄存器模型的扩展：

- 通用寄存器（AX -> EAX）
- 指令指针寄存器（IP -> EIP）
- 标志寄存器（FLAGS -> EFLAGS）
- 段寄存器仍然都为 16 位，增加了 FS 和 GS 两个段寄存器

IA-32 的寻址方式：

- 实模式：CS:IP
- 保护模式：
  - Global Descriptor Table（GDT）：全局描述符表，由 8 字节的描述符组成，包含段基址、段界限等信息
  - GDTR：GDT 寄存器，存放 GDT 的基址和界限
  - CS：存放段选择子
  - 段基址由根据 GDTR 和 CS，查内存中的 GDT 得到
  - EIP：存放指令的段内偏移地址
- 物理地址 = 段基址 + 段内偏移地址

### 64 位时代：x86-64

AMD Opteron：

- 首款 64 位 x86 处理器
- 兼容 IA-32，且不降低性能

x86-64 的运行模式：

- 长模式：64 位 OS
  - 64 位模式：需要重新编译
  - 兼容模式：不需要重新编译
- 传统模式：都不需要重新编译
  - 保护模式：32 位或 16 位 OS
  - 虚拟 8086 模式：32 位或 16 位 OS
  - 实模式：16 位 OS

x86-64 对寄存器模型的扩展：

- 通用寄存器（EAX -> RAX），并且增加了 R8-R15 寄存器
- 指令指针寄存器（EIP -> RIP）
- 标志寄存器（EFLAGS -> RFLAGS）
- 段寄存器没有变化，仍然为 6 个 16 位寄存器（CS、DS、SS、ES、FS、GS）

x86-64 半废除了 GDT 寻址，GDT 描述符表的基址和界限都为 0，段选择子也不再使用，通过分页寻址。

## x86 指令简介

主要分为传送类、运算类（又可分为算术、逻辑）、控制类、转移类。

字节（BYTE）为 8 位，字（WORD）为 16 位，双字（DWORD）为 32 位，四字（QWORD）为 64 位。

Intel 语法：`MOV WORD PTR [BX + SI*2 + 200H], 01H`

- 目的在前，源在后
- `[]` 表示内存地址
- `WORD PTR` 表示操作数大小
- `H` 后缀表示十六进制，`D` 表示十进制，`B` 表示二进制，`O` 表示八进制

MOV：

- 立即数不能为目的
- 不能在存储器之间传送，不能在段寄存器之间传送
- 不能将立即数传送到段寄存器
- CS 不能为目的

栈操作：PUSH、POP

LEA：将地址（而不是地址中的数据）传送到通用寄存器中

算术运算指令：

- 目的不能是立即数或 CS
- 源和目的不能都是存储器
- 加法：ADD、ADC（目的 + 源 + CF）、INC
- 减法：SUB、SBB（目的 - 源 - CF）、DEC、CMP（DST - SRC，但不写回目的，只设置标志位）

逻辑运算指令：

- 单操作数指令，操作数不能是立即数
- 双操作数指令，限制同 MOV 指令（目的不能是立即数或 CS，源和目的不能都是存储器也不能都是段寄存器，不能将立即数传送到段寄存器）
- NOT、AND
- SHL 逻辑左移（乘 $2^n$）
- SHR 逻辑右移，SAR 算术右移（除以 $2^n$）

转移指令：

- 无条件转移：
  - 直接转移
    - `JMP SHORT LABEL`：LABEL 是地址，指令中存储的是 IP 到 LABEL 的 8 位偏移量，范围 -128 ~ 127。执行效果：`IP = IP + OFFSET`
    - `JMP NEAR PTR LABEL`：16 位偏移量，范围 -32768 ~ 32767（80386 支持 32 位偏移量）。执行效果：`IP = IP + OFFSET`
    - `JMP FAR PTR LABEL`：指令中存储的是 LABEL。执行效果：`CS = LABEL.CS`、`IP = LABEL.IP`
  - 间接转移：`JMP AX`、`JMP [BX]`、`JMP FAR PTR [SI]`（执行效果如 `IP = [SI]; CS = [SI + 2]`）
- 条件转移：
  - `C`：进位
  - `P`：奇偶
  - `Z`/`E`：零/相等
  - `S`：符号（负数）
  - `O`：溢出
  - `B(E)`、`A(E)`：小于 (等于)/大于 (等于)（无符号数）
  - `L(E)`、`G(E)`：小于 (等于)/大于 (等于)（有符号数）

处理器控制指令：

- 标志操作
  - STC：设置进位标志 CF
  - CLC：清除进位标志 CF
  - CMC：取反进位标志 CF
- 外同步：HLT（停止 CPU）
- NOP

复杂 x86-64 指令举例：串操作指令

- 串的基本单位：字节（BYTE）或字（WORD）
- 串长可达 64KB
- 五种串操作指令：MOVS、CMPS、SCAS、LODS、STOS，每种有 B 和 W 两种形式
- 三种重复前缀：REP、REPE、REPNE
- 隐含操作数：
  - 源串：DS:SI
  - 目的串：ES:DI
  - 串长：CX
  - 方向标志 DF（0：从低地址到高地址，1：从高地址到低地址）
- 传送过程中，SI、DI、CX 自动更新

## MIPS 体系结构

设计者：约翰·亨尼西

RISC（Reduced Instruction Set Computer，精简指令集计算机）、CISC（Complex Instruction Set Computer，复杂指令集计算机）

MIPS（Microprocessor without Interlocked Pipeline Stages，微处理器无互锁流水线阶段）：

- 32 位定长指令
- 指令少、简单
- 仅 Load/Store 指令可访问内存
- 寻址简单
- 需要优秀的编译器

MIPS 的通用寄存器：`$0` - `$31`，分为若干组。

MIPS 指令分为 R 型、I 型、J 型：

- R 型：
  - 格式：[6 位 opcode, 5 位 rs, 5 位 rt, 5 位 rd, 5 位 shamt, 6 位 funct]
  - 所有 R 型指令的 opcode 都为 0，funct 决定具体指令
  - shamt：移位量，只对移位指令有效
  - rs、rt：源寄存器，rd：目的寄存器
- I 型：
  - 格式：[6 位 opcode, 5 位 rs, 5 位 rt, 16 位 immediate]
  - 与 R 型指令的区别：无 shamt、rd、funct
  - rs：源寄存器，rt：目的寄存器
  - immediate：立即数或地址偏移量
- J 型：
  - 格式：[6 位 opcode, 26 位 address]
  - 无条件跳转
  - 目的地址 = {PC[31:28], address, 00}，即 PC 的高 4 位 + 指令中的地址 + 00（低两位）
  - MIPS 指令 32 位定长，所有指令地址都是 32 位（4 字节）对齐的，所以低两位都是 00

分支指令：

- 条件分支：I 型
  - BEQ/BNE rs, rt, offset：如果 rs 和 rt 相等（不相等），则跳转到 (PC + 4) + offset * 4
- 无条件分支：J 型和 R 型
  - `j addr`：正负 256MB 跳转
  - `jr rs`：4GB 跳转

# 算术逻辑单元

`add $8, $9, $10` 的执行过程：

- 取指：指令被取到 IR
- 译码：分析出指令类型、操作数，通过控制电路将加法命令传给 ALU，并将 `$9` 和 `$10` 的输出通过内部总线送到 ALU 的输入
- 执行：
  - ALU：执行加法操作，输出结果
  - 状态寄存器：设置状态标志位（如进位、零、符号、溢出等）
- 回写：将 ALU 的输出通过内部总线送到 `$8` 寄存器

算术运算指令 `add` 和 `sub` 可能引发溢出异常，带后缀 `u` 则不会。（溢出仅针对有符号数，有符号数的溢出会改变符号）

- 有溢出不一定有进位：四位有符号数加法 `0b0011 + 0b0101 = 0b1000`
- 有进位不一定有溢出：四位无符号数加法 `0b1111 + 0b0001 = 0b0000`。当然也可以说无符号数的进位是无符号数的溢出，因为其结果不在表示范围内。
- 溢出：**最高位的进位输入不等于最高位的进位输出**
  - 溢出其实就是两个正数相加得到负数，或者两个负数相加得到正数
  - 只看最高位的全加器：
    - 若输入为两个正数，即 $A = B = 0$，则进位输出 $C_{out}$ 必然为 $0$；溢出当且仅当 $S = 1$，这要求 $C_{in} = 1$，满足 $C_{in} \neq C_{out}$
    - 若输入为两个负数，即 $A = B = 1$，则进位输出 $C_{out}$ 必然为 $1$；溢出当且仅当 $S = 0$，这要求 $C_{in} = 0$，满足 $C_{in} \neq C_{out}$
    - 即：溢出 $OF = C_{in} \oplus C_{out}$
- MIPS 没有 OF，有符号数溢出会引发异常。x86 不会引发异常，只会设置 OF。

I 型加法指令 `addi` 中的立即数是 16 位的，运算时会有符号扩展为 32 位。它也有不引发溢出异常的版本 `addiu`。

I 型逻辑运算指令 `andi`、`ori` 会对立即数进行零扩展。

晶体管（transistor）：现代集成电路通常用 Metal-Oxide-Semiconductor (MOS) 晶体管。

- NMOS：当 Gate 为高电平时，Drain 和 Source 之间导通
- PMOS：当 Gate 为低电平时，Drain 和 Source 之间导通
- 两种晶体管组合成 Complementary MOS (CMOS) 晶体管
- 非门、与非门、与门、或门、异或门

D 触发器（D Flip-Flop）：

- 有存储能力的基本单元，由逻辑门构成
- 一个数据输入，一个时钟输入，一个输出
- 在时钟上升沿时，数据输入的值被锁存到输出中。在其他时刻，无论数据输入的值如何变化，输出都保持不变。
- CLK-to-Q 延迟：时钟上升沿到输出稳定的时间
- Setup/Hold 时间：数据输入在时钟上升沿前/后必须保持稳定的时间
  - 类比：显示器和相机
- 两个 D 触发器连起来，如果它们的时钟上升沿同时到达，则第一个触发器的输出不一定和第二个触发器的输出一致（可能是第一个触发器先前的输出）。
- 32 个 D 触发器连起来，就是一个 32 位寄存器

32 位与运算：并联 32 个与门。

将不同的 32 位运算单元再并联起来，再加上一个多选器选择运算结果，就可以实现 ALU。

半加器（Half Adder）：将两个一位二进制数相加，输出和与进位。

- 注意到 $S = A + B = A \oplus B$，$C = A \cdot B$
- 半加器就是一个异或门和一个与门

全加器（Full Adder）：将两个一位二进制数和一个进位相加，输出和与进位。

- 注意到 $S = A + B + C_{in} = A \oplus B \oplus C_{in}$，$C_{out} = A \cdot B + (A \oplus B) \cdot C_{in}$
- 由两个半加器和一个或门组成
- 把 32 个全加器串联起来，前一个的进位输出连接下一个的进位输入，就可以实现 32 位加法器

减法：转换为加法，$A - B = A + (-B) = A + \sim B + 1$

- 在先前的 32 位加法器的第二个输入前添加一个 2-to-1 多选器
- 多选器的选择信号连接到最低位全加器的进位输入
- 如果多选器的选择信号为 $0$，则输出为 B，正常计算 $A + B$
- 如果多选器的选择信号为 $1$，则输出为 $\sim B$，计算减法 $A + \sim B + 1$，即 $A - B$（$1$ 来自最低位全加器的进位输入）

先前的加法器是行波进位加法器（Ripple Carry Adder），优点是简单，缺点是高位运算必须等待低位运算完成，延迟累积。

- 记门延迟为 $T$，线延迟为零，则 32 位加法器的总延迟是 $3T + 31\times 2T = 65T$
- 需要提前计算进位信号

注意到 

$$C_{i+1} = (A_i \cdot B_i) + (A_i \cdot C_i) + (B_i \cdot C_i),$$

设

- $G_i = A_i \cdot B_i$：生成（Generate）信号
- $P_i = A_i \oplus B_i$：传播（Propagate）信号
- 这两个信号都由 $A$ 和 $B$ 决定，可以并行地计算出来，延迟不会累积

则 

$$C_{i+1} = G_i + P_i \cdot C_i.$$

将这个式子不断迭代展开，可以得到 $C_{32}$ 的表达式：

$$
\begin{align*}
C_{32} &= G_{31} \\
&+ P_{31} \cdot G_{30} \\
&+ P_{31} \cdot P_{30} \cdot G_{29} \\
&\vdots \\
&+ P_{31} \cdot P_{30} \cdots P_1 \cdot G_0 \\
&+ P_{31} \cdots P_1 \cdot P_0 \cdot C_0
\end{align*}
$$

此时，进位信号的延迟固定为 $3T$：

- 从 $A, B$ 计算 $G, P$ 为 $T$
- 展开式中的与运算延迟为 $T$
- 最后的或运算延迟为 $T$
- 每一位的运算都是并行的
- 缺点：电路复杂，位数越多越复杂
- 整个加法器的延迟为 $3T + T = 4T$（最高位进位信号通过最后一个全加器需要 $T$ 的延迟）

改进后的加法器称为超前进位加法器（Carry-Lookahead Adder, CLA）。32 位完全的超前进位加法器的延迟为 $4T$，但电路过于复杂难以实现，一般使用多个小 CLA 用行波进位的方式连接起来。

# 乘法器与除法器

## 乘法器

只有零和一的十进制乘法和二进制乘法是一样的。

$N$ 位乘法器的组成：

- 被乘数寄存器：$N$ 位，带左移
- 乘数寄存器：$N$ 位，带右移
- 积寄存器：$2N$ 位
- 加法器：$2N$ 位

$N$ 位乘法器的工作流程：

1. 检查乘数寄存器最低位：
  - 如果为 $1$，将被乘数寄存器的值加到积寄存器中
  - 这个分支实际上可以取消：相当于先将乘数寄存器最低位和被乘数取与，然后再加到积寄存器中
2. 将被乘数寄存器的值左移一位
3. 将乘数寄存器的值右移一位
4. 如果这是第 $N$ 次循环，则结束；否则，返回第 1 步

时间优化（性能优化）：

- 分析：加法、左移、右移都需要一个时钟周期，$N$ 位乘法将需要约 $3N$ 个时钟周期。
- 优化：将加法和移位操作并行
  - 控制逻辑同时给出加法、左移和右移信号，在下一个时钟上升沿时，这三个操作就能并行完成
  - 被乘数寄存器的移位不会影响加法，因为移位操作完成时，被乘数寄存器的值已经发给输出端口了
- 现在，乘法器只需要 $N$ 个时钟周期。

空间优化（面积优化）：

- 分析：
  - 被乘数寄存器有 $2N$ 位，但其中有效位只有 $N$ 位
  - 乘数寄存器有 $N$ 位，但每次右移后，它的有效位就减少一位
  - 乘积寄存器有 $2N$ 位，但每次加法的有效数字只有 $N$ 位
  - 加法器 $2N$ 位，但每次加法的有效数字只有 $N$ 位
- 优化：
  - 被乘数寄存器缩减为 $N$ 位，不左移
  - 乘积寄存器仍然为 $2N$ 位，初始有效数字存放在高 $N$ 位，随运算过程不断右移
  - 加法器也被自然缩减为 $N$ 位，每次取出乘积寄存器的高 $N$ 位与被乘数寄存器相加
  - 取消乘数寄存器，将乘数放在乘积寄存器的低 $N$ 位中，并将其与控制逻辑相连（随着右移，这低 $N$ 位的乘数逐渐被移出）
- 优化后乘法器的组成：
  - 被乘数寄存器：$N$ 位
  - 乘积寄存器：$2N$ 位，带右移
  - 加法器：$N$ 位


## 除法器

只有零和一的十进制除法和二进制除法是一样的。

$N$ 位除法器的组成：

- 余数寄存器：$2N$ 位
- 除数寄存器：$2N$ 位，带右移
- 商寄存器：$N$ 位，带左移
- ALU：$2N$ 位，支持加法和减法

$N$ 位除法器的工作流程：

1. 余数 = 余数 - 除数
2. 检查余数最高位：
   - 若为 $1$，即余数为正，则商寄存器左移一位，并将最低位置 $1$
   - 若为 $0$，即余数为负，则将除数加回余数（回滚），商寄存器左移一位
3. 除数寄存器右移一位
4. 如果这是第 $N$ 次循环，则结束；否则，返回第 1 步

空间优化（面积优化）：

- 分析：
  - 除数寄存器有 $2N$ 位，但其中有效位只有 $N$ 位
  - 商寄存器初始时空，随着运算过程逐渐填满
  - 余数寄存器初始时满，随着运算过程逐渐清空
- 优化：
  - 除数寄存器缩减为 $N$ 位，不右移
  - 取消商寄存器，商从低位逐位移入余数寄存器
  - ALU 也被自然缩减为 $N$ 位，每次取出余数寄存器的高 $N$ 位与除数寄存器做加减法
  - 运算完成后，余数寄存器的高 $N$ 位就是余数，低 $N$ 位就是商（余数寄存器还需要支持右移，从而取出余数）
- 优化后除法器的组成：
  - 余数寄存器：$2N$ 位，带左移、右移
  - 除数寄存器：$N$ 位
  - ALU：$N$ 位，支持加法和减法

这种除法器不容易做时间优化了，它不像乘法器那样可以并行地做加法和移位。


# 单周期处理器

简化 MIPS 指令集：

- 无符号加减法：
  - `addu rd, rs, rt`
  - `subu rd, rs, rt`
- 立即数的逻辑或：
  - `ori rt, rs, imm16`
- 加载存储：
  - `lw rt, imm16(rs)`
  - `sw rt, imm16(rs)`
- 条件分支：
  - `beq rs, rt, imm16`

指令集的硬件需求：

- ALU：
  - 支持加法、减法、逻辑或、比较相等
  - 操作数：2 个 32 位数，来自寄存器或 32 位立即数
- 立即数扩展部件
  - 将 16 位立即数扩展为 32 位
  - 符号扩展和零扩展
- PC
  - 一个 32 位寄存器
  - 两种加法：
    - PC + 4：取指令地址
    - PC + 4 + imm16 * 4：分支跳转地址
- 寄存器堆
  - 32 个 32 位寄存器
  - 两个读端口，一个写端口
- 存储器
  - 只读的指令存储器（32 位地址，32 位数据）
  - 读写的数据存储器（32 位地址，32 位数据）

寄存器堆：

- 32 个 32 位寄存器
- 数据接口信号：
  - busA, busB：32 位读端口
  - busW：32 位写端口
- 读写控制：
  - Ra, Rb：5 位寄存器编号，分别对应 busA 和 busB
  - Rw：5 位寄存器编号，对应 busW
  - WriteEnable：写使能信号，在时钟信号 clk 的上升沿，若 WriteEnable == 1，则将 busW 写入对应寄存器
- 注意：寄存器堆的读操作不受时钟控制

存储器：

- 数据接口信号：
  - Data In：32 位数据输入
  - Data Out：32 位数据输出
- 读写控制
  - Address：32 位地址
  - WriteEnable：写使能信号，在时钟信号 clk 的上升沿，若 WriteEnable == 1，则将 Data In 写入 Address 指向的存储单元
- 一个读端口，一个写端口

## 数据通路

取值单元（Instruction Fetch Unit, IFU）：

- 组成部件
  - PC：程序计数器
  - 指令存储器
  - 两个加法器
  - 多选器：选择 PC + 4 或分支跳转地址
  - 与门：跳转当且仅当 `nPC_set == 1` 且 `zero == 1`
  - 立即数符号扩展并左移部件
- 输入：
  - 时钟信号 clk 
  - 分支跳转信号 nPC_set
  - ALU 的比较结果信号 zero
- 输出：
  - 指令

译码、执行、访存、写回单元：

- 组成部件
  - 寄存器堆
  - ALU
  - 立即数扩展部件
  - 多选器：从 rd 和 rt 中选择寄存器堆 busW
  - 多选器：从立即数扩展部件输出和寄存器堆 busB 中选择 ALU 的第二个输入
  - 数据存储器
  - 多选器：从 ALU 输出和数据存储器输出中选择寄存器堆 busW
- 输入：
  - 时钟信号 clk
  - ALUCtr：执行哪种运算
  - ALUSrc：ALU 的第二个输入的选择信号
  - 立即数
  - RegWr：寄存器堆写使能信号
  - RegDst：寄存器堆写端口选择信号
  - ExtOp：立即数扩展的选择信号（符号扩展或零扩展）
  - MemtoReg：寄存器堆 busW 选择信号
  - MemWr：数据存储器写使能信号（是否将 busB 写入数据存储器）

R 型运算指令的控制信号：以 `addu rd, rs, rt` 为例：

- nPC_set："+4"
- ALUSrc："0"，ALU 的第二个输入来自寄存器堆 busB
- ExtOp: 任意
- ALUCtr："ADD"
- MemWr: "0"
- MemtoReg: "0"，寄存器堆 busW 选择 ALU 的输出
- RegWr: "1"
- RegDst: "1"，寄存器堆写端口选择寄存器 rd

I 型运算指令的控制信号：以 `ori rt, rs, imm16` 为例：

- nPC_set："+4"
- ALUSrc："1"，ALU 的第二个输入来自立即数扩展部件
- ExtOp: "0"，立即数扩展为零扩展
- ALUCtr："OR"
- MemWr: "0"
- MemtoReg: "0"，寄存器堆 busW 选择 ALU 的输出
- RegWr: "1"
- RegDst: "0"，寄存器堆写端口选择寄存器 rt

加载指令的控制信号：以 `lw rt, imm16(rs)` 为例：

- nPC_set："+4"
- ALUSrc："1"，ALU 的第二个输入来自立即数扩展部件
- ExtOp: "1"，立即数扩展为符号扩展
- ALUCtr："ADD"
- MemWr: "0"
- MemtoReg: "1"，寄存器堆 busW 选择数据存储器的输出
- RegWr: "1"
- RegDst: "0"，寄存器堆写端口选择寄存器 rt

跳转指令的控制信号：以 `beq rs, rt, imm16` 为例：

- nPC_set："branch"
- ALUSrc："0"，ALU 的第二个输入来自寄存器堆 busB
- ExtOp: 任意
- ALUCtr："SUB"
- MemWr: "0"
- MemtoReg: "x"
- RegWr: "0"
- RegDst: "x"

## 控制信号的集成

指令类型的控制信号可以由 opcode 和 func 只经**逻辑与**得到：

- rtype = ~op5 & ~op4 & ~op3 & ~op2 & ~op1 & ~op0
  - 即 op 的 6 位都为 0
- add = rtype & func5 & ~func4 & ~func3 & ~func2 & ~func1 & ~func0
  - 即指令为 R 型且 func 为 100000
- sub = rtype & func5 & ~func4 & ~func3 & func2 & func1 & ~func0
  - 即指令为 R 型且 func 为 100010
- 其余指令同理

控制 CPU 执行的 8 个控制信号可以由指令类型的控制信号只经**逻辑或**得到：

- nPC_set = beq
- ALUSrc = ori | lw | sw
- ExtOp = lw | sw
- ALUCtr[0] = sub | beq
- ALUCtr[1] = ori
- MemWr = sw
- MemtoReg = lw
- RegWr = add | sub | ori | lw
- RegDst = add | sub

其中 ALUctr 有两位：

- 00：加法
- 01：减法
- 10：逻辑或

